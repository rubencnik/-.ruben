# Вариант 13. Решите задачу о расстановке N ферзей для N = 8
# Описание алгоритма с синтаксисом на языке Pyton
1. Подготовка исходных данных
Создается пустая шахматная доска размером 8×8 (если рассматривать общий случай, то N×N). Все клетки изначально свободны (будут помечены цифрой 0). 
```
board = [[0]*8 for _ in range(8)]
```
Описание: Здесь создаётся двухмерный массив, каждая клетка которого равна 0 (означает отсутствие ферзя).

2. Определение вспомогательной функции для проверки безопасности постановки ферзя
Необходимо проверить, безопасно ли ставить ферзя на данную клетку. Клетка считается безопасной, если там не находятся другие ферзи.
Реализуется функция `is_safe()`
```
def is_safe(board, row, col):
```
Эта функция возвращает `True`, если клетка безопасна, иначе `False`

3. Основная логика рекурсивной процедуры для перебора вариантов (метод `backtracking`)
Используя рекурсию, будем пытаться расставлять ферзей поочередно в разных клетках, начиная с первой строки. Важно проверять перед каждым шагом безопасность позиции. Если какое-то положение оказалось неверным, происходит откат назад, чтобы попробовать другое направление.
Реализация функции:
```
solve_n_queens():
```
Описание: Рекурсивная функция `backtrack()` проходит по строкам доски. Каждая новая попытка заключается в попытке поставить ферзя в разные столбцы выбранной строки. Если клетка безопасна, ферзь ставится, и идёт переход к следующей строке. Если решить задачу не удаётся, ферзь снимается, и выбирается следующая клетка.

4. Вспомогательная подфункция
Отвечает за визуализацию текущих решений. 
Реализация функции:
```
print_board():
```
Описание: Вместо цифр (1 для ферзя, 0 для пустой ячейки) используются символы ('Q' для ферзя и '.' для пустых клеток).

5. Выполнение и вывод результата
Мы можем вызвать нашу функцию `solve_n_queens()` с аргументом 8, чтобы получить все возможные способы расстановки ферзей на доске 8×8.

```
if __name__ == "__main__":
    solve_n_queens(8)
```
Программа выдаёт все правильные конфигурации, где ферзи расположены безопасным образом.

# Временная сложность и ее анализ
Временная сложность - O(n!)

# Почему O(n!):
1. Количество возможных расстановок сильно ограничено правилами задачи, однако сама природа backtracking предполагает экспоненциальный рост пространства поиска, так как приходится выбирать позиции для каждого ферзя независимо от других (хотя фактически некоторые выборы будут отсекаться благодаря проверке безопасности).
2. Временная сложность такого типа характерна для многих комбинаторных задач, особенно тех, которые решаются методом полного перебора с элементами оптимизации (например, путём исключения недопустимых путей).
3. Для небольших значений N (например, N=8), этот алгоритм вполне приемлем и даёт быстрые результаты. Однако с ростом N эффективность резко падает из-за роста факториальной зависимости.

Таким образом сложности кроется в природе проблемы: необходимо перебрать большое количество возможных комбинаций расстановки ферзей, проверяя каждое возможное состояние на безопасность. 

# Ответ на контрольный вопрос
В чем суть алгоритма backtracking?
Backtracking — это метод решения задач путем систематического перебора всех возможных вариантов решения. Алгоритм строит решение пошагово и откатывается назад (backtrack), когда обнаруживает, что текущий путь не приведет к решению.
