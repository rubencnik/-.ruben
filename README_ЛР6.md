АЛГОРИТМЫ СОРТИРОВКИ

СОРТИРОВКА ВЫБОРОМ (Selection Sort)
Это алгоритм сортировки, при котором выбирается наименьший (или наибольший) элемент массива и перемещается в начало (или конец). Процесс продолжается до тех пор, пока весь массив не окажется упорядоченным.
Анализ алгоритма:
Он состоит из двух вложенных циклов:
 • Внешний цикл (for (int i = 0; i < n - 1; ++i)): проходит по элементам массива слева направо от первого до предпоследнего.
 • Внутренний цикл (for (int j = i + 1; j < n; ++j)): ищет наименьший элемент среди тех, что расположены справа от текущего.
После нахождения минимального значения производится обмен элементов с помощью функции std::swap().
Временная сложность: O(n²)
Почему: из-за двух вложенных циклов. Каждый из них в худшем случае выполняется до n раз, что приводит к квадратичной зависимости времени работы.

СОРТИРОВКА ОБМЕНОМ (пузырьковая, Bubble Sort)
Этот алгоритм многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они расположены неправильно. Процесс продолжается, пока весь массив не будет отсортирован.
Анализ алгоритма:
 • Внешний цикл контролирует количество проходов по списку — на каждом проходе наибольший элемент «всплывает» в конец.
 • Внутренний цикл сравнивает соседние элементы и меняет их местами при необходимости. С каждым новым проходом количество проверяемых элементов уменьшается, так как крайние уже упорядочены.
Временная сложность: O(n²)
Почему: в худшем случае требуется n*(n-1)/2 сравнений и возможных обменов, как и при сортировке выбором.

СОРТИРОВКА ВСТАВКАМИ (Insertion Sort)
При этом методе каждый новый элемент вставляется в правильное место среди уже отсортированных. Сначала рассматривается первый элемент как отсортированный, затем алгоритм двигается вправо.
Анализ алгоритма:
 • Основной цикл (for i in range(1, len(arr))) проходит по всем элементам, начиная со второго, и вставляет каждый на нужную позицию.
 • Внутренний цикл (while j >= 0 and key < arr[j]) сдвигает элементы вправо, пока не найдётся место для вставки текущего.
 • После этого выполняется вставка (arr[j + 1] = key).
Временная сложность: O(n²)
Почему: в худшем случае количество сравнений и сдвигов равно 1 + 2 + 3 + ... + (n-1) = n*(n-1)/2.

СОРТИРОВКА СЛИЯНИЕМ (Merge Sort)
Алгоритм разделяет массив на две части, сортирует их рекурсивно и затем объединяет в один отсортированный.
Анализ алгоритма:
 • Рекурсивная функция mergeSort(vector& arr, int left, int right) делит массив на части и сортирует каждую.
 • Функция слияния merge(vector& arr, int left, int mid, int right) объединяет отсортированные подмассивы.
Обмен элементов напрямую не выполняется — используется перенос данных из временных массивов L и R обратно в arr.
Временная сложность: O(n log n)
Почему: на каждом уровне рекурсии выполняется O(n) операций, а глубина рекурсии равна log₂n. Итог — O(n log n).

СОРТИРОВКА ШЕЛЛА (Shell Sort)
Это усовершенствованный вариант сортировки вставками, который сортирует элементы, находящиеся на определённом расстоянии (шаге) друг от друга.
Анализ алгоритма:
 • Внешний цикл (while gap > 0) управляет изменением шага.
 • Внутренний цикл (for i in range(gap, len(arr))) проходит по массиву, начиная с индекса, равного текущему шагу.
 • Подцикл (while j >= gap and arr[j-gap] > temp) отвечает за перемещение элементов и вставку текущего (temp) в нужную позицию.
Временная сложность: O(n²)
Почему: присутствуют вложенные циклы, но внутренний цикл выполняется меньше, чем n раз. Средняя сложность ниже, но в худшем случае — O(n²).

БЫСТРАЯ СОРТИРОВКА (Quick Sort)
Суть алгоритма — выбрать опорный элемент, разделить массив на две части (меньшие и большие этого элемента), а затем рекурсивно отсортировать эти части.
Анализ алгоритма:
 • Опорный элемент выбирается, например, как середина массива (pivot = arr[len(arr) // 2]).
 • Формируются три списка: left (меньше опорного), middle (равные опорному), right (больше опорного).
 • Рекурсивные вызовы выполняются для левой и правой частей: return quick_sort(left) + middle + quick_sort(right).
Временная сложность: O(n²)
Почему: при неудачном выборе опорного элемента (например, массив уже отсортирован) время работы возрастает до квадратичного.

ПИРАМИДАЛЬНАЯ СОРТИРОВКА (Heap Sort)
Метод основан на построении кучи (heap) из элементов массива и последовательном извлечении максимального элемента с последующим восстановлением свойств кучи.
Анализ алгоритма:
 • Функция heapify(vector& arr, int n, int root) поддерживает структуру кучи, обеспечивая, что родитель всегда больше своих потомков.
 • Основная функция heapSort(vector& arr) сначала формирует max-кучу, затем поочерёдно извлекает элементы и восстанавливает порядок.
Временная сложность: O(n log n)
Почему: каждая операция подъёма или спуска элемента в куче выполняется за O(log n), а таких операций n.


АЛГОРИТМЫ ПОИСКА

ПОСЛЕДОВАТЕЛЬНЫЙ (ЛИНЕЙНЫЙ) ПОИСК
Алгоритм перебирает все элементы массива по порядку, пока не найдёт нужный или не дойдёт до конца.
Анализ алгоритма:
Функция linear_search(arr, target) принимает массив и значение для поиска.
Цикл for index, value in enumerate(arr) перебирает элементы, а если value == target, возвращает индекс.
Временная сложность: O(n)
Почему: в худшем случае необходимо проверить каждый элемент массива.

БИНАРНЫЙ (ДВОИЧНЫЙ, ДИХОТОМИЧЕСКИЙ) ПОИСК
Используется для отсортированных массивов. Каждый шаг делит диапазон пополам, сокращая область поиска.
Анализ алгоритма:
Функция binary_search(arr, target) работает в цикле while low <= high.
Вычисляется средний индекс: mid = (low + high) // 2.
Если значение меньше среднего — поиск идёт в левой половине (high = mid - 1), если больше — в правой (low = mid + 1).
Временная сложность: O(log n)
Почему: на каждом шаге диапазон сокращается вдвое.

ИНТЕРПОЛЯЦИОННЫЙ ПОИСК
Этот метод применим к отсортированным данным с равномерным распределением значений. Он оценивает позицию искомого элемента по формуле.
Анализ алгоритма:
Функция interpolationSearch(int arr[], int n, int target) выполняет цикл while ((low <= high) && (target >= arr[low]) && (target <= arr[high])).
При равенстве low == high проверяется единственная позиция.
Предполагаемая позиция вычисляется по формуле:
pos = low + (((double)(high - low) / (arr[high] - arr[low])) * (target - arr[low]));
Временная сложность: O(n)
Почему: при неравномерном распределении значений приходится просматривать почти весь массив.

ПОИСК ПО ФИБОНАЧЧИ (Fibonacci Search)
Эффективный алгоритм для отсортированных массивов, использующий числа Фибоначчи для определения позиций сравнения.
Анализ алгоритма:
Сначала генерируются числа Фибоначчи (fib_m_minus_2 = 0, fib_m_minus_1 = 1, fib_M = fib_m_minus_2 + fib_m_minus_1), пока не будет найдено число, большее длины массива.
Цикл while fib_M > 1 выполняет последовательные проверки, вычисляя индекс i = min(offset + fib_m_minus_2, len(arr)-1).
В конце проводится дополнительная проверка последнего элемента.
Временная сложность: O(log n)
Почему: аналогична бинарному поиску — на каждом шаге область поиска уменьшается логарифмически.
