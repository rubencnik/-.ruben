# Задание 2. Метод ближайшего соседа (TSP)
## Условие. Дан граф городов с расстояниями. Найти приближённый маршрут коммивояжёра, стартуя из города 0. Алгоритм: ближайший сосед.
### Определение самого алгоритм
Алгоритм ближайшего соседа — это жадный эвристический алгоритм для решения задачи коммивояжёра (TSP), который на каждом шаге выбирает локально оптимальное решение, переходя к ближайшему непосещённому городу из текущего положения.
- Жадный (Greedy) — выбирает наилучший вариант на текущем шаге
- Эвристический — не гарантирует оптимальное решение
- Детерминированный — при одинаковых входных данных даёт одинаковый результат
### Анализ алгоритма
1. Инициализация структур данных
В начале работы алгоритма мы подготавливаем все необходимые структуры данных. Создаём пустой список, который будет хранить последовательность посещения городов. Также создаём специальный массив для отметки о посещении каждого города - это важно, чтобы не возвращаться в уже пройденные города. Стартовой точкой всегда выбирается город с номером 0, что упрощает алгоритм и делает его детерминированным.
`List<Integer> path = new ArrayList<>();`
2. Начало маршрута
Алгоритм начинает свой путь с добавления стартового города в маршрут. Этот шаг критически важен, так как устанавливает начальную точку путешествия. Одновременно мы помечаем этот город как посещённый в нашем массиве отслеживания. Эта отметка предотвращает повторное посещение города в будущем, что соответствует условию задачи коммивояжёра - каждый город должен быть посещён ровно один раз.
`path.add(curr);`
3. Основной цикл построения маршрута
Сердце алгоритма - это цикл, который продолжается до тех пор, пока все города не будут включены в маршрут. На каждом витке этого цикла мы добавляем ровно один новый город в наш путь. Количество итераций точно равно количеству городов минус один, поскольку первый город уже добавлен на предыдущем шаге. Этот цикл обеспечивает систематическое построение полного маршрута.
`while (path.size() < dist.length) {`
4. Поиск ближайшего города
На каждой итерации алгоритм просматривает все города в поисках ближайшего непосещённого соседа. Это самый вычислительно затратный этап, но именно он определяет "жадную" природу алгоритма. Для каждого города проверяются три условия: что город ещё не посещён, что расстояние до него меньше текущего минимального найденного, и что расстояние положительное (исключает переход в тот же город). Этот поиск гарантирует, что на каждом шаге мы выбираем локально оптимальное решение.
`if (!visited[i] && dist[curr][i] < minDist && dist[curr][i] > 0) {`
5. Обновление рекорда расстояния
Когда находится город, удовлетворяющий всем условиям и находящийся ближе текущего рекорда, алгоритм обновляет свои "рекордные показатели". Запоминается новое минимальное расстояние и идентификатор города-кандидата. Этот механизм позволяет алгоритму последовательно сравнивать все возможные варианты и выбирать наилучший на текущем моменте. Именно здесь проявляется "жадность" алгоритма - он не заглядывает вперёд, а выбирает лучшее прямо сейчас.
`minDist = dist[curr][i];`
6. Расширение маршрута
После завершения поиска среди всех городов найденный ближайший город добавляется в конец маршрута. Этот город немедленно помечается как посещённый, чтобы исключить его из рассмотрения на последующих шагах. Текущая позиция "коммивояжёра" перемещается в этот новый город, и с этой точки будет начинаться поиск на следующей итерации. Это последовательное расширение маршрута напоминает построение цепочки, где каждое новое звено присоединяется к предыдущему.
`path.add(nextCity);`
7. Конкретный пример работы
Рассмотрим практический пример с пятью городами. Из начального города 0 коммивояжёр видит расстояния: 10, 15, 20, 30 до городов 1, 2, 3, 4 соответственно. Выбирается город 1 с расстоянием 10. Теперь из города 1 доступны города 2, 3, 4 с расстояниями 35, 25, 40 - выбирается город 3. Процесс продолжается до полного охвата всех городов. Такой пошаговый подход гарантирует, что маршрут будет построен, но не обязательно оптимально.
8. Вычисление итоговой длины
После построения полного маршрута необходимо вычислить его общую длину. Для этого последовательно суммируются расстояния между соседними городами в полученном порядке. Этот расчёт подтверждает, что построенный маршрут действительно является решением задачи, хотя и приближённым. Длина служит мерой качества решения - чем она меньше, тем лучше маршрут.
9. Завершение работы
Алгоритм завершает свою работу, возвращая построенный маршрут. Важно понимать, что это эвристическое решение - оно не гарантирует нахождение кратчайшего возможного пути, но обеспечивает разумное приближение за приемлемое время. Такой компромисс между качеством решения и вычислительной сложностью делает алгоритм практичным для реальных применений.
`return path;`
Итоговый результат алгоритма: Маршрут, проходящий через все города ровно по одному разу, с относительно небольшой общей длиной пути, построенный за квадратичное время относительно количества городов.
### Оценка временной сложности
Временная сложность алгоритма ближайшего соседа: O(n²)
### Почему именно такая временная сложность
1. Внешний цикл while:
- Выполняется n-1 раз (так как первый город уже добавлен)
- Каждая итерация добавляет один город в маршрут
2. Внутренний цикл for:
- На каждой итерации внешнего цикла просматривает все n городов
- Ищет минимальное расстояние среди непосещённых городов
3. Математически:
- Количество операций: (n-1) × n = n² - n
- В асимптотической нотации: O(n²)
Всё это создаёт временную сложность O(n²)
### Ответ на контрольный вопрос 
#### Дайте определение коэффициента аппроксимации α для задачи минимизации. Что он характеризует?
Коэффициент аппроксимации α ≥ 1 для задачи минимизации — это максимальное отношение стоимости решения, найденного приближённым алгоритмом, к стоимости оптимального решения (A(I)/OPT) для всех возможных входных данных. Он характеризует гарантированную верхнюю границу "плохости" алгоритма: если α = 2, то алгоритм гарантированно не выдаст решение хуже, чем в 2 раза от оптимального, а чем ближе α к 1, тем лучше гарантия качества алгоритма.


