АЛГОРИТМЫ СОРТИРОВКИ

СОРТИРОВКА ВЫБОРОМ
#include <iostream>   // Подключаем библиотеку ввода-вывода

// Функция для сортировки массива методом выбора
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {      // Внешний цикл проходит по элементам массива
        int minIndex = i;                   // Предполагаемый индекс минимального элемента

        // Внутренний цикл ищет минимальный элемент среди оставшихся элементов справа
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {  // Если найден новый минимум, обновляем индекс
                minIndex = j;
            }
        }
        
        // Меняем местами текущий элемент с минимальным элементом
        std::swap(arr[i], arr[minIndex]);  // Используем встроенную функцию swap()
    }
}

// Вспомогательная функция для вывода отсортированного массива
void printArray(const int arr[], int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << ' ';       // Печать каждого элемента массива
    }
    std::cout << '\n';                    // Перевод строки после печати всего массива
}

// Основная точка входа программы
int main() {
    const int SIZE = 8;                  // Размер тестового массива
    int array[] = {64, 25, 12, 22, 11}; // Исходный массив для сортировки

    std::cout << "Исходный массив:\n";
    printArray(array, SIZE);              // Вывод исходного состояния массива

    selectionSort(array, SIZE);           // Выполняем сортировку

    std::cout << "\nОтсортированный массив:\n";
    printArray(array, SIZE);              // Выводим отсортированный массив

    return 0;                            // Завершаем программу успешно
}

Исходный массив:
64 25 12 22 11 32591 -2075079224 8 
Отсортированный массив:
-2075079224 8 11 12 22 25 64 32591 

СОРТИРОВКА СЛИЯНИЕМ
#include <iostream>
#include <vector>
using namespace std;

// Вспомогательная функция для объединения двух отсортированных частей массива
void merge(vector<int>& arr, int left, int mid, int right) {
    // Размеры левой и правой половинок
    int n1 = mid - left + 1; // Левая половина: от left до mid включительно
    int n2 = right - mid;     // Правая половина: от mid+1 до right включительно

    // Создание временных массивов для хранения обеих половинок
    vector<int> L(n1), R(n2);

    // Копирование данных в временные массивы
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i]; // Заполнение левой половины
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j]; // Заполнение правой половины
    }

    // Индексы для временного массива L, временного массива R и основного массива arr
    int i = 0, j = 0, k = left;

    // Объединение двух отсортированных частей обратно в исходный массив
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++];
        } else {
            arr[k++] = R[j++];
        }
    }

    // Добавление оставшихся элементов из левой части, если таковые имеются
    while (i < n1) {
        arr[k++] = L[i++];
    }

    // Добавление оставшихся элементов из правой части, если таковые имеются
    while (j < n2) {
        arr[k++] = R[j++];
    }
}

// Рекурсивная функция сортировки слиянием
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        // Нахождение середины массива
        int mid = left + (right - left) / 2;

        // Рекурсивно сортируем обе половины
        mergeSort(arr, left, mid);     // Сортируем левую половину
        mergeSort(arr, mid + 1, right);// Сортируем правую половину

        // Объединяем отсортированные половины
        merge(arr, left, mid, right);
    }
}

// Основная программа
int main() {
    vector<int> arr = {38, 27, 43, 3, 9, 82, 10};
    cout << "Исходный массив: ";
    for (auto x : arr) {
        cout << x << " "; // Выводим исходный массив
    }
    cout << endl;

    // Запускаем процедуру сортировки
    mergeSort(arr, 0, arr.size() - 1);

    cout << "Отсортированный массив: ";
    for (auto x : arr) {
        cout << x << " "; // Выводим отсортированный массив
    }
    cout << endl;

    return 0;
}

Исходный массив: 38 27 43 3 9 82 10 
Отсортированный массив: 3 9 10 27 38 43 82 

ПИРАМИДАЛЬНАЯ СОРТИРОВКА 
#include <iostream>
#include <vector>
using namespace std;

// Функция для преобразования двоичного дерева в кучу (heapify)
void heapify(vector<int>& arr, int n, int root) {
    /**
     * Эта функция поддерживает свойство кучи (max-heap),
     * восстанавливая дерево, начиная с корня.
     */
    int largest = root; // Начальный корень узла
    int leftChild = 2 * root + 1; // Левый дочерний узел
    int rightChild = 2 * root + 2; // Правый дочерний узел

    // Если левый дочерний узел больше корневого, устанавливаем его крупнейшим
    if (leftChild < n && arr[leftChild] > arr[largest])
        largest = leftChild;

    // Если правый дочерний узел больше корневого, устанавливаем его крупнейшим
    if (rightChild < n && arr[rightChild] > arr[largest])
        largest = rightChild;

    // Если крупнейший элемент не является корневым узлом, меняем их местами
    if (largest != root) {
        swap(arr[root], arr[largest]); // Меняем местами узлы
        heapify(arr, n, largest); // Рекурсивно поддерживаем свойство max-heap
    }
}

// Основная функция для сортировки массива методом Heap Sort
void heapSort(vector<int>& arr) {
    int n = arr.size();

    // Строим max-кучу (heap) из массива
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i); // Приводим поддерево к виду max-heap

    // Достаем максимальные элементы и переносим их в конец массива
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]); // Перемещаем текущий максимум в конец
        heapify(arr, i, 0); // Восстанавливаем max-heap свойства для оставшейся части
    }
}

// Основная программа
int main() {
    vector<int> arr = {12, 11, 13, 5, 6, 7};
    cout << "Исходный массив: ";
    for (int num : arr)
        cout << num << " ";
    cout << endl;

    heapSort(arr); // Запускаем процедуру сортировки

    cout << "Отсортированный массив: ";
    for (int num : arr)
        cout << num << " ";
    cout << endl;

    return 0;
}

Исходный массив: 12 11 13 5 6 7 
Отсортированный массив: 5 6 7 11 12 13 

АЛГОРИТМЫ ПОИСКА 

ИНТЕРПОЛИРУЮЩИЙ ПОИСК
#include <iostream>
using namespace std;

// Интерполирующая функция поиска
int interpolationSearch(int arr[], int n, int target) {
    int low = 0;                         // Нижняя граница поиска
    int high = n - 1;                    // Верхняя граница поиска

    // Цикл продолжается, пока нижний индекс меньше или равен верхнему
    while ((low <= high) && (target >= arr[low]) && (target <= arr[high])) {
        // Если нижний и верхний индексы одинаковы, возвращаем индекс нижнего
        if (low == high) {
            if (arr[low] == target) return low;
            return -1;
        }

        // Расчёт ожидаемого положения искомого элемента
        // Формула учитывает относительное расположение цели в пределах отрезка
        int pos = low + (((double)(high - low) /
                          (arr[high] - arr[low])) *
                         (target - arr[low]));

        // Если найден элемент, возвращаем его индекс
        if (arr[pos] == target)
            return pos;

        // Если элемент меньше среднего, уменьшаем верхнюю границу
        if (arr[pos] < target)
            low = pos + 1;

        // Иначе увеличиваем нижнюю границу
        else
            high = pos - 1;
    }

    // Если элемент не найден, возвращаем -1
    return -1;
}

// Основная программа
int main() {
    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};
    int n = sizeof(arr) / sizeof(arr[0]);
    int target = 18;

    // Запускаем процедуру поиска
    int index = interpolationSearch(arr, n, target);

    // Выводим результат
    if (index != -1)
        cout << "Элемент " << target << " найден на индексе " << index << "." << endl;
    else
        cout << "Элемент " << target << " не найден." << endl;

    return 0;
}

Элемент 18 найден на индексе 4.