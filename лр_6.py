АЛГОРИТМЫ СОРТИРОВКИ

СОРТИРОВКА ОБМЕНОМ
def bubble_sort(arr):
    
    n = len(arr)  # Получаем длину входящего массива
    
    # Цикл продолжается до тех пор, пока список не будет полностью отсортирован
    for i in range(n):
        # Переменная для отслеживания наличия перемещений на текущей итерации
        swapped = False
        
        # Обходим список от начала до конца (за исключением уже проверенных элементов)
        for j in range(0, n-i-1):
            
            # Если текущий элемент больше последующего, меняем их местами
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True  # Фиксируем факт свершившегося обмена
                
        # Если на текущей итерации не случилось ни одного обмена,
        # значит массив уже отсортирован, и можем выйти из цикла
        if not swapped:
            break

# Тестирование функции
array = [64, 34, 25, 12, 22, 11, 90]
print("Исходный массив:", array)

bubble_sort(array)

print("Отсортированный массив:", array)

Исходный массив: [64, 34, 25, 12, 22, 11, 90]
Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]

СОРТИРОВКА ВСТАВКАМИ
def insertion_sort(arr):
    
    # Проходим по всему массиву, начиная со второго элемента
    for i in range(1, len(arr)):
        key = arr[i]                     # Текущий элемент, который будем вставлять на нужное место
        j = i - 1                        # Индекс элемента слева от current_element
        
        # Сравниваем ключ с предыдущими элементами, двигаясь назад
        while j >= 0 and key < arr[j]:   # Пока не дошли до начала и элемент слева больше ключа
            arr[j + 1] = arr[j]          # Смещаем больший элемент вправо
            j -= 1                       # Переходим к следующему левому элементу
        
        # Ставим текущий элемент на свободное место
        arr[j + 1] = key                 # Ключ занимает правильное положение

# Пример использования
array = [12, 11, 13, 5, 6]
print("Исходный массив:", array)
insertion_sort(array)
print("Отсортированный массив:", array)

Исходный массив: [12, 11, 13, 5, 6]
Отсортированный массив: [5, 6, 11, 12, 13]

СОРТИРОВКА ШЕЛЛА
def shell_sort(arr):
    
    gap = len(arr) // 2  # Первоначальный промежуток (расстояние между элементами)

    # Уменьшаем разрыв до тех пор, пока он не достигнет нуля
    while gap > 0:
        # Приступаем к сортировке подсегментов
        for i in range(gap, len(arr)):
            temp = arr[i]  # Сохраняем текущий элемент
            j = i

            # Движемся назад по массиву, выполняя сравнения с интервалом gap
            while j >= gap and arr[j-gap] > temp:
                arr[j] = arr[j-gap]  # Перемещение большего элемента вперёд
                j -= gap  # Перемещаемся на шаг назад

            # Устанавливаем временно сохранённый элемент на его новую позицию
            arr[j] = temp

        # Уменьшаем промежуток вдвое для следующей итерации
        gap //= 2

# Пример использования
arr = [64, 34, 25, 12, 22, 11, 90]
shell_sort(arr)
print("Отсортированный массив:")
print(arr)

Отсортированный массив:
[11, 12, 22, 25, 34, 64, 90]

БЫСТРАЯ СОРТИРОВКА
def quick_sort(arr):
   
    if len(arr) <= 1:
        return arr  # Базовый случай: пустой массив или массив из одного элемента уже отсортирован

    pivot = arr[len(arr) // 2]  # Выбираем средний элемент в качестве опорного

    # Формируем три списка: элементы меньше опорного, равные и больше опорного
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # Рекурсивно сортируем левую и правую части, соединяем с центральной частью
    return quick_sort(left) + middle + quick_sort(right)

# Пример использования
array = [3, 6, 8, 10, 1, 2, 1]
sorted_array = quick_sort(array)
print(f'Отсортированный массив: {sorted_array}')

Отсортированный массив: [1, 1, 2, 3, 6, 8, 10]

АЛГОРИТМЫ ПОИСКА 

ПОСЛЕДОВАТЕЛЬНЫЙ ПОИСК
def linear_search(arr, target):
    
    # Перебираем элементы массива с индексами
    for index, value in enumerate(arr):
        # Если текущий элемент равен искомому значению
        if value == target:
            # Возвращаем индекс найденного элемента
            return index
    # Если элемент не найден, возвращаем -1
    return -1

# Пример использования
array = [4, 2, 7, 1, 9, 3]
target_value = 7

result = linear_search(array, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на индексе {result}.")
else:
    print(f"Элемент {target_value} не найден.")

Элемент 7 найден на индексе 2.

БИНАРНЫЙ ПОИСК
def binary_search(arr, target):
    
    low = 0                          # Нижняя граница диапазона поиска
    high = len(arr) - 1              # Верхняя граница диапазона поиска

    while low <= high:               # Пока диапазон поиска не исчерпался
        mid = (low + high) // 2      # Находим средний индекс

        # Если целевой элемент найден, возвращаем его индекс
        if arr[mid] == target:
            return mid

        # Если целевой элемент меньше среднего, сужаем поиск слева
        elif arr[mid] > target:
            high = mid - 1

        # Если целевой элемент больше среднего, сужаем поиск справа
        else:
            low = mid + 1

    # Если элемент не найден, возвращаем -1
    return -1

# Пример использования
array = [1, 3, 5, 7, 9, 11, 13, 15]
target_value = 9

result = binary_search(array, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на индексе {result}.")
else:
    print(f"Элемент {target_value} не найден.")

Элемент 9 найден на индексе 4.

ПОИСК ПО ФИБОНАЧЧИ
def fibonacci_search(arr, target):
    
    # Генерация чисел Фибоначчи до тех пор, пока последнее число не станет больше длины массива
    fib_m_minus_2 = 0  # F(k−2)
    fib_m_minus_1 = 1  # F(k−1)
    fib_M = fib_m_minus_2 + fib_m_minus_1  # F(k)

    while fib_M < len(arr):
        fib_m_minus_2 = fib_m_minus_1
        fib_m_minus_1 = fib_M
        fib_M = fib_m_minus_2 + fib_m_minus_1

    offset = -1  # Начало поиска

    # Основное тело поиска
    while fib_M > 1:
        i = min(offset + fib_m_minus_2, len(arr)-1)  # Индекс, который будем проверять

        # Если элемент найден, возвращаем его индекс
        if arr[i] == target:
            return i

        # Если элемент больше целевого, движемся влево
        elif arr[i] < target:
            fib_M = fib_m_minus_1
            fib_m_minus_1 = fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1
            offset = i

        # Если элемент меньше целевого, движемся вправо
        else:
            fib_M = fib_m_minus_2
            fib_m_minus_1 = fib_m_minus_1 - fib_m_minus_2
            fib_m_minus_2 = fib_M - fib_m_minus_1

    # Отдельная проверка последнего элемента
    if fib_m_minus_1 and arr[offset+1] == target:
        return offset + 1

    # Если элемент не найден, возвращаем -1
    return -1

# Пример использования
array = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
target_value = 85

result = fibonacci_search(array, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на индексе {result}.")
else:
    print(f"Элемент {target_value} не найден.")

Элемент 85 найден на индексе 8.