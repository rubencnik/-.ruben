def is_safe(board, row, col):
    """
    Функция проверяет, безопасно ли ставить ферзя на заданную позицию (строку и столбец).
    Она смотрит на предыдущие ряды, чтобы убедиться, что новый ферзь не угрожает другим ферзям.
    :param board: Текущая доска игры (матрица NxN)
    :param row: Строка, куда хотим поставить ферзя
    :param col: Столбец, куда хотим поставить ферзя
    :return: True, если позиция безопасна, иначе False
    """
    # Проходим по предыдущим рядам вертикально вверх
    for i in range(row):  
        if board[i][col]:  # Если на этой высоте уже есть ферзь в данном столбце, возвращаем False
            return False

    # Проверяем диагонали слева-вверх
    x = row
    y = col
    while x >= 0 and y >= 0:
        if board[x][y]:  # Если здесь находится ферзь, эта позиция небезопасна
            return False
        x -= 1
        y -= 1

    # Проверяем диагонали справа-вверх
    x = row
    y = col
    while x >= 0 and y < len(board):
        if board[x][y]:  # Опять проверка наличия ферзя на диагоналях
            return False
        x -= 1
        y += 1

    return True  # Если никаких угроз нет, позиция безопасна


def solve_n_queens(n):
    """
    Основная функция для нахождения всех решений задачи N ферзей.
    Используем метод Backtracking (рекурсия с возвратом).
    :param n: Размер доски (доска n*n)
    """
    def backtrack(row):
        """Рекурсивная функция, реализующая сам процесс перебора"""
        nonlocal solutions_count  # Используем глобальную переменную solutions_count
        if row == n:  # Если достигли последнего ряда, нашли одно возможное решение
            solutions_count += 1
            print("Решение №", solutions_count)
            print_board()  # Печать текущего расположения ферзей
            return
        
        # Пробегаемся по каждому возможному столбцу в строке
        for col in range(n):
            if is_safe(board, row, col):  # Проверяем, безопасно ли ставить ферзя сюда
                board[row][col] = 1  # Ставим ферзя на выбранную позицию
                backtrack(row + 1)   # Переход к следующему ряду
                board[row][col] = 0  # Убираем ферзя обратно (Backtracking)

    def print_board():
        """Функция для вывода состояния доски на экран."""
        for r in range(n):
            line = []  # Создаем список для каждой строки
            for c in range(n):
                if board[r][c] == 1:  # Ферзь обозначается буквой Q
                    line.append('Q')
                else:                 # Пустое поле обозначено точкой .
                    line.append('.')
            print(' '.join(line))     # Преобразование списка в строку и вывод
        print()                       # Добавляем пустую строку для удобства восприятия следующего решения

    # Инициализация игровой доски (все поля пусты)
    global board
    board = [[0]*n for _ in range(n)]  # Доска представляет собой матрицу nxn нулей
    solutions_count = 0                 # Начальное число решений равно нулю
    backtrack(0)                        # Запуск процесса с первого ряда
    print(f'Всего решений найдено: {solutions_count}')  # Итоговая статистика количества решений

# Решим задачу для классической шахматной доски 8x8
solve_n_queens(8)