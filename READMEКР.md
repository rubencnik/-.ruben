Блочная(корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины объединяются обратно в один массив.

Принцип работы
Определение максимального и минимального значений: max_value = max(arr) min_value = min(arr) Эти операции нужны для расчета ширины диапазонов каждого бака.

Создание баков: buckets = [[] for _ in range(bucket_count)]

Распределение элементов по бакам: index = int((value - min_value) // bucket_size) Каждое значение размещается в соответствующий бак, основываясь на своем положении в общем диапазоне.

Сортировка каждого бака: final_result.extend(insertion_sort(bucket)) Используется простая сортировка вставками для каждого отдельного бака.

Сборка результатов: Все отсортированные баки сливаются в единый отсортированный массив.

Анализ временной сложности в худшем случае**
Распределение элементов по бакам: O(n), где n — количество элементов в массиве. Сортировка каждого бака: Среднее время работы сортировки вставками в одном бакете — O(m*logm), где m — среднее количество элементов в баке. Обычно предполагается, что количество элементов в каждом баке близко к m≈k, где k — количество баков. Но в худшем случае (все элементы попадают в один бак), сложность становится O(n^2), так как фактически приходится применять внутреннюю сортировку ко всему массиву целиком.

Итак, в худшем случае, временная сложность блочной сортировки достигает O(n^2), что объясняется возможностью концентрации всех элементов в одном баке, приводящей к полной сортировке вставками большого объема данных.

Блинная сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

Принцип работы
Функция flip(): def flip(arr, k): Эта функция переворачивает первые k элементов массива. Она меняет местами пары элементов, двигаясь навстречу друг другу от краев к центру.

Функция pancake_sort(): def pancake_sort(arr): Главная логика алгоритма: Сначала находим индекс наибольшего элемента в текущей несортированной части массива. Если наибольший элемент не находится в конце текущей части, делаем два переворота: Первый переворот поднимает наибольший элемент наверх. Второй переворот опускает наибольший элемент вниз, на его конечное место. Затем уменьшаем размер несортированной части и повторяем процедуру.

Основной цикл: while current_size > 1 Цикл продолжается, пока остается хотя бы два несортированных элемента.

Операция нахождения максимума: max_index = arr.index(max(arr[:current_size])) Находит индекс наибольшего элемента в текущей несортированной части массива.

Два последовательных переворота: flip(arr, max_index + 1)flip(arr, current_size) Два переворота обеспечивают перемещение наибольшего элемента на нужное место.

Временная сложность в худшем случае:
Временная сложность блинной сортировки в худшем случае — O(n^2).

Обоснование:

Нахождение максимума:Каждая итерация включает операцию поиска наибольшего элемента в текущей части массива, что требует O(n) операций. Количество итераций:Всего выполняется n−1 итераций (каждый раз уменьшается размер несортированной части на единицу). Перевороты:Каждый переворот требует O(n) операций (перестановка элементов). Таким образом, суммируя временную сложность для каждого алгоритма, получаем O(n^2)

Сортировка бусинами
Определение: Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.

Принцип работы
Получение максимальной высоты столбца: max_height = max(arr) Нам нужно знать максимальную высоту столбца, чтобы создать матрицу правильной формы.

Формирование матрицы бусинок: beads_matrix = [[False]*len(arr) for _ in range(max_height)] Матрица размером max_height*len(arr), где False означает отсутствие бусинки.

Заполнение матрицы бусинками: for col, height in enumerate(arr):
Столбец за столбцом устанавливаем бусинки в матрице.

"Падение" бусинок: for row in range(max_height):

Для каждого ряда подсчитывается количество бусинок и они сдвигаются влево, имитируя свободное падение.

Восстанавливаем отсортированный массив: for col in range(len(arr)):

Подсчитываем новую высоту каждого столбца, которая теперь соответствует отсортированному порядку.

Временная сложность в худшем случае:
Временная сложность сортировки бусинами в худшем случае — O(n⋅k), где n — количество элементов в массиве, а k — максимальная величина в массиве.

Обоснование:

Создание матрицы бусинок:Требует O(n⋅k) операций, так как создаётся матрица размером k×n. Подсчёт и перераспределение бусинок:Для каждого ряда матрицы требуется O(n) операций для подсчета и перемещения бусинок. Поскольку рядов k, общая сложность этапа — O(n⋅k). Восстанавливаем отсортированный массив:Ещё одна операция O(n⋅k), так как для каждого столбца требуется просмотреть все ряды. Таким образом, общая временная сложность — O(n⋅k).

Важно отметить, что эффективность этого алгоритма сильно зависит от величины k (максимального значения в массиве). Если k велико, алгоритм становится крайне неэффективным. Именно поэтому сортировка бусинами редко применяется на практике, кроме случаев, когда k ограничено небольшим диапазоном.

Поиск скачками (Jump Search)
Определение: Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного диапазона.

Принцип работы
Вычисление оптимального шага: step = int(math.sqrt(n)) Оптимальный шаг определяется как квадратный корень из длины массива. Это обеспечивает баланс между пропусками и точностью поиска.

Поиск подходящего блока: while arr[min(step, n) - 1] < target:
Осуществляется серия прыжков длиной step, пока не найдём блок, в котором может находиться целевой элемент.

Линейный поиск в блоке: while arr[prev] < target: Внутри выбранного блока проводится линейный поиск точного положения цели.

Финальная проверка: if arr[prev] == target:return prev Проверяется совпадение текущего элемента с целью.

Временная сложность
Временная сложность поиска скачком в худшем случае — O(sqrt(n))

Обоснование:

Оптимальность выбора шага:Выбор шага как sqrt(n) оптимален, так как позволяет минимизировать сумму двух компонентов: Количество блоков, которые нужно посетить: n/sqrt(n)=sqrt(n)

Максимальная длина линейного поиска в блоке:sqrt(n)​Общая сложность:Общая временная сложность получается суммой этих компонент: sqrt(n)+sqrt(n)=2*sqrt(n), что упрощается до О(sqrt(n))

Экспоненциальный поиск (Exponential Search)
Определение: Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

Принцип работы
Двоичный поиск:def binary_search(arr, low, high, x) Классический двоичный поиск, используемый после нахождения границы для точного поиска.

Экспоненциальный поиск (exponential_search()): def exponential_search(arr, x) Основная функция, реализующая саму стратегию поиска.

Инициализация границ: while i < n and arr[i] <= x:i *= 2 Здесь экспоненциально расширяется область поиска до тех пор, пока не будет найдена первая позиция, превышающая целевой элемент.

Переход к двоичному поиску:low = i // 2 high = min(i, n - 1) Устанавливаем нижнюю и верхнюю границы для последующего двоичного поиска.

Применение двоичного поиска: return binary_search(arr, low, high, x) Завершающим этапом выступает применение классического двоичного поиска в ограниченном диапазоне.

Временная сложность
Временная сложность экспоненциального поиска в худшем случае — O(logn).

Обоснование:

Первый этап (определение начальной точки):За счёт экспоненциального увеличения границы, этот этап выполняется за O(logn) шагов, так как каждое удвоение удваивает охват.

Второй этап (двоичный поиск):Обычный двоичный поиск также выполняется за O(logn) времени.

Следовательно, суммарная временная сложность равна O(logn)+O(logn)=O(logn).
